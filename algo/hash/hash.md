# Hash

## Closed addressing
- Solution: chaining, 使用 linked list，當多個鍵被哈希到同一個位置時，使用一個鏈表將這些鍵值對存儲在同一個“桶”裡。
- 實現方式： 每個哈希表槽位是一個鏈表，如果發生衝突，新的鍵值對會被附加到這個槽位的鏈表中。
- 優點：
1. 容易實現，尤其適合處理大量元素的情況。
2. 不需要擔心表滿時進行擴容。
- 缺點：
1. 可能會因為衝突增加，鏈表變長，從而降低查找效率。

## Open addressing
- 解決collision: 探測法
- 常見: 
1. Linear probing 線性探測: 如果哈希表某個位置已被佔用，就依次向後查找空位。
2. Quadratic Probing 二次探測: 衝突時不是線性移動，而是根據二次函數進行移動（如1, 4, 9...）
3. Double Hashing 雙重哈希: 使用兩個哈希函數，當發生衝突時，利用第二個哈希函數來決定跳轉的步數。
- 優點：
1. 內存利用率更高
- 缺點：
1. 表滿時會需要大量重新探測，性能會下降。
2. 須有良好的探測策略，否則可能發生無窮循環。

## function: 
- put(key, value) : 插入鍵值，發生衝突時 (CA:鏈表末尾插入。 OA:探測法解決衝突。)
- get(key) : 查找鍵，遍歷鏈表找到對應的值
- remove(key) : 刪除鍵值對，從鏈表中刪除。(OA: 可能需要標記為“已刪除”以避免探測失效。)

