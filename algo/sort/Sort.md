# Sort

## Buble Sort 冒泡排序 ✅
- 時間複雜度: O(n²)
- 反覆比較相鄰元素並交換，使較大的元素逐步移動到數組末尾。
- 適合數據小且性能不高的情境，可以在不需額外空間情況下排序(原地排序)

## Selection Sort 選擇排序 ✅
- 時間複雜度: O(n²)
- 每次遍歷找到最小元素，並將其與當前遍歷位置的元素交換
- 類似 bubble，適合數據小且存儲空間有限的情境，原地排序

## Insertion Sort 插入排序 ✅
- 時間複雜度: O(n²)（平均和最壞情況），O(n)（最佳情況）
- 將元素逐一插入到已排序的部分，保持數組部分有序。
- 小規模的數據集，適合對少量或部分有序數據排序，原地排序
- 適合應用於小型嵌入式系統

## Merge Sort 合併排序 ✅
- 時間複雜度: O(n log n)
- 將數組遞歸地拆分成兩部分(divide and conquer)，分別排序後再合併。
- 適合大規模數據集，特別是需要穩定排序的場合，ex: 兩個已排序的數據合併
- 外部排序，適用於當數據量過大，無法一次載入內存的情況（如磁碟排序）。

## Quick Sort 快速排序
- 時間複雜度: O(n log n)（平均情況），O(n²)（最壞情況）
- 選定一個基準元素，將數組分成兩部分，小於基準的在左，大於基準的在右，然後遞歸排序。
- 內存內排序，處理大規模數據效率高。
- ex: Python, C++ 的 sort 函數
- 適合處理需要高性能的情況，但數據過於規律(ex: 完全逆序) 則效率變差。

## Heap Sort 堆排序
- 時間複雜度: O(n log n)
- 將數組構建成最大堆，然後反覆將堆頂元素移至數組末尾，並重新構建堆。
- 適合需要穩定 O(n log n)時間複雜度 & 空間有限，非遞迴排需且只需少量額外內存
- 可用於優先級隊列，例如在模擬、排程或圖演算法中的應用。

## Shell Sort 希爾排序 
- 時間複雜度: O(n log² n)（平均情況），O(n²)（最壞情況）
- 基於插入排序，通過逐步減少比較間距來加速排序過程。
- 希爾排序是一種改進的插入排序，適合處理中等規模的數據。它在數據量較大且需要在較少的內存中進行排序時非常實用，因為它不需要額外的內存。

## Radix Sort 基數排序
- 時間複雜度: O(nk)，其中 k 是數字的位數
- 按位數對數組元素進行排序，從最低位到最高位逐步排序。
- 基數排序對數字排序非常有效，尤其是當數據的位數固定且範圍較大時。例如，對大量的銀行交易 ID 進行排序。
- 它通常與計數排序結合，用於處理大範圍的整數數據。

## Counting Sort 計數排序
- 時間複雜度: O(n + k)，其中 k 是數據範圍
- 計數排序適合處理範圍有限且為整數的數據集，如對於學生成績範圍在 0-100 的情況下，計數排序表現優異。
- 它在時間複雜度上能夠優於 O(n log n)，但需要大量額外內存，適合數據範圍較窄的應用。

## Bucket Sort 桶排序
- 時間複雜度: O(n + k)，其中 k 是桶的數量
- 當數據均勻分佈在一個已知範圍內時，桶排序的效果非常好。例如對浮點數進行排序，將它們劃分到不同的範圍（桶）中，再使用其他排序方法（如插入排序）對桶內的數據進行排序。
- 它在圖形學和數字圖像處理中的應用廣泛，特別是在直方圖和統計數據分析中。

### 應用總結
小規模數據集：插入排序、冒泡排序、選擇排序
大規模數據集：快速排序、合併排序、堆排序
數據範圍有限：計數排序、基數排序、桶排序
需要穩定排序：合併排序、計數排序、基數排序
內存空間有限：堆排序、快速排序